#!/bin/env python3
# -----------------------------------------------------------------------------------------
# leonard heywang <leonard.heywang@proton.me>
# 07-01-2026
#
# Thiscomplex tool is charged from a single, but quite large task : Generate the
# .sym and optionnaly a top level verilog file.
# This script is used to generate an abstraction layer for the user to directly map
# more than just XSCHEM element into their schematic, such as veriloga models or digital
# verilog models, without needing to know how, ad where to place each declarations.
#
# This tool expose some quality of live features such as :
# - pin grouping for digital logic. By default, it won't expose multiple times the nets
#   that share the same name : clk, rstn... It also work from outputs to inputs.
# - Multiple options to configure files names, voltages used on the interfaces and so on...
# -----------------------------------------------------------------------------------------
import argparse
import textwrap
from pathlib import Path
import datetime
import subprocess
import shlex
from dataclasses import dataclass

from pyverilog.vparser.parser import parse
from pyverilog.vparser.ast import ModuleDef, Width
from pyverilog.vparser.ast import Input as astInput
from pyverilog.vparser.ast import Output as astOutput
from pyverilog.vparser.ast import Inout as astInout


@dataclass(frozen=True)
class dataport:
    """
    This class store the elements required to define a single port of a verilog(a) module.

    Functions :
        -> get_port_name() -> Return the port names including the bus expansion.

    Members :
        -> name -> name of the port
        -> direction -> Is the IO an input or an input (inout aren't handled.)
        -> width -> Verilog formatted bus width, if needed. Otherwise 0:0, which is perfectly valid.
        -> id -> id of the port, incremented by one on each new port. Enable to track orders and others things like that.

    """

    name: str
    direction: str
    width: str
    id: int

    def get_ports_name(self) -> str:
        """
        This function return the name of a port, and handle the bus expansion if needed.

        Arguments :
            -> None

        Returns :
            -> str : A string formatted with else the name "clk", or the bus with an index suffix "q.3 q.2 q.1 q.0".
        """
        MSB = int(self.width.split(":")[0])
        LSB = int(self.width.split(":")[1])

        # If there's more than one bit, iterate from the higher order down to the
        # lowest index in the port range. That enable to generate ports with the right width, and
        # which are spice compatible.
        ports = []
        if (MSB - LSB) > 0:
            for index in range((MSB - LSB), -1, -1):
                ports.append(f"{self.name}.{index}")
        # Else, just return the bare port name
        else:
            ports.append(f"{self.name}")

        # Return that as a list of elements separated by a comma.
        return " ".join(ports)


def va2v(input: Path, output: Path) -> str:
    """
    This small function generate a verilog stub from a VerilogA file.

    Arguments :
        -> input : The source VerilogA file
        -> output : The target Verilog file (stub)

    Returns :
        -> str : A string that contain the declarative part of the VerilogA file. Used when re-generating the verilogA file.

    """
    data = None

    # First, fetch data as a single line (enable splits) :
    with open(input, "r") as f:
        data = f.read().strip().replace("\n", "#")

    # Split to known keywords that are mandatory :
    corps = data.split("analog begin")[1].replace("#", "\n")
    data = data.split("module")[1].split("analog begin")[0].strip()

    # Restore newlines
    data = data.replace("#", "\n").split("\n")

    # Remove unwanted lines :
    for line in data:
        if "electrical" in line:
            data.remove(line)

    # Finally, write the new file :
    with open(output, "w+") as f:
        f.write(f"// THIS FILE WAS AUTOGENERATED. DO NOT EDIT.\n")
        f.write(f"// ORIGINAL FILE WAS : {str(input)}\n\n")

        f.write("module ")

        for line in data:
            if len(line.strip()) > 1:
                f.write(f"{line.strip()}\n")

        f.write("endmodule\n\n")
        f.write(f"// FILE WAS CREATED ON :{datetime.datetime.now()}\n\n")

    return corps


def parse_file(
    files: list[Path],
) -> tuple[list[dataport], list[dataport], list[str]]:
    """
    This function parse verilog files and list the IO ports and found modules.

    Arguments :
        -> files : List of files as Pathlib objects to be parsed.

    Returns :
        -> list of inputs as dataport class(es)
        -> list of outputs as dataport class(es)
        -> list of the module names that were found.
    """

    # Init ports
    ins = []
    outs = []
    modules = []

    id = 0

    for file in files:
        print(f"Parsing file : {str(file)} ...")
        ast, directives = parse([f"{str(file)}"])

        for item in ast.description.definitions:
            if not isinstance(item, ModuleDef):
                continue

            for port in item.portlist.ports:
                elems = port.children()

                for elem in elems:
                    if isinstance(elem, (astInput, astOutput, astInout)):

                        width = "0:0"
                        if isinstance(elem.width, Width):
                            width = f"{elem.width.msb}:{elem.width.lsb}"

                        if isinstance(elem, astInput):
                            ins.append(
                                dataport(
                                    f"{item.name}#{elem.name}",
                                    "INPUT",
                                    str(width),
                                    id,
                                )
                            )
                        elif isinstance(elem, astOutput):
                            outs.append(
                                dataport(
                                    f"{item.name}#{elem.name}",
                                    "OUTPUT",
                                    str(width),
                                    id,
                                )
                            )

                        id += 1

            modules.append(f"{item.name}")

    return ins, outs, modules


def match_ports(
    inputs: list[dataport], outputs: list[dataport]
) -> tuple[list[dataport], list[dataport], list[dataport], list[dataport]]:
    """
    This function identify the ports that can be shared by their same name.
    Does also link outputs to inputs if possible.

    Arguments :
        -> inputs : A list of dataport objects to be linked.
        -> outputs : A list of dataport objects to be linked.

    Returns :
        -> inputs : A list of dataport objects that was removed from duplicated.
        -> outputs : A list of dataport objects that was removed from duplicated.
        -> wires : The list of dataport objects that will be shared.
        -> internals : The list of dataport objects to be internalized.
    """
    wires = []
    internals = []

    matches = []

    def get_wires(
        ports_in: list[dataport], ports_out: list[dataport], matched: list[str]
    ) -> list[dataport]:
        t_wires = []

        # That's not really nice in terms of performance O(n2), but as they're top modules, we don't expect very long lists, the delta is acceptable.
        for port1 in ports_in:
            for port2 in ports_out:
                if port1 is port2:
                    continue

                p_name = port1.name.split("#")[-1]
                if p_name == port2.name.split("#")[-1]:
                    if p_name not in matched:
                        t_wires.append(
                            dataport(
                                port1.name.split("#")[-1],
                                port1.direction,
                                port1.width,
                                port1.id,
                            )
                        )
                        matched.append(p_name)

        return t_wires, matched

    # end of function

    # Matching the ports within them :
    tmp, matches = get_wires(inputs, inputs, matches)
    wires.extend(tmp)

    # Matching port that are output to inputs
    tmp, matches = get_wires(outputs, inputs, matches)
    internals.extend(tmp)

    # Removing duplicates
    wires = list(set(wires))
    internals = list(set(internals))

    return inputs, outputs, wires, internals


def generate_module(
    target: Path,
    analog: bool,
    modules: list[str],
    inputs: list[dataport],
    outputs: list[dataport],
    wires: list[dataport],
    internals: list[dataport],
    analog_decl: str,
) -> None:
    """
    This function generate the top level file for both Verilog and VerilogA modes.

    Arguments :
        -> target : The file where we're going to print on.
        -> analog : If True, the generated file is VerilogA, else Verilog.
        -> modules : The list of the used modules.
        -> inputs : The list of dataport objects that will be exposed as inputs.
        -> outputs : The list of dataport objects that will be exposed as outputs.
        -> wires : The list of dataport objects that will be shared.
        -> internals : The list of dataport objects that won't be exposed to the outside.
        -> analog_decl : The string that contain the analog declaration of the source VerilogA file. Only used when analog == True.

    Returns :
        -> None
    """

    with open(target, "w+") as f:
        # Adding some basic verilog features
        f.write(f"// =========================================\n")
        f.write(f"// THIS FILE WAS AUTOGENERATED. DO NOT EDIT.\n")
        f.write(f"// =========================================\n\n")

        # Include standard libs if needed :
        if analog == True:
            f.write('`include "constants.h"\n')
            f.write('`include "discipline.h"\n\n')

        f.write(f"module {target.stem} (\n")

        # Generating a global net list and add them to the module
        globnet = []
        for wire in wires:
            globnet.append(wire.name)
            # Add the comma if needed :
            f.write(
                f"\n    {wire.direction.lower():8} [{str(wire.width).center(8)}] {wire.name.replace("#", "_")},"
            )

        # Generating a wire net list and add them to the module
        internet = []
        for wire in internals:
            internet.append(wire.name)

        def append_nets(netlist: list[dataport], type: str, mode: bool):
            # Iterate over the nets :
            for net in netlist:

                # Ensure the net is not global
                if (net.name.split("#")[-1] not in globnet) and (
                    net.name.split("#")[-1] not in internet
                ):

                    # Write the net and update the first
                    if mode == False:
                        f.write(
                            f"\n    {type:8} [{str(net.width).center(8)}] {net.name.replace("#", "_")},"
                        )
                    else:
                        f.write(f"\n    {type:8} {net.name.split("#")[-1]},")

        # Adding unique ports :
        append_nets(inputs, "input", analog)
        append_nets(outputs, "output", analog)

        # Delete the last comma
        f.seek(f.tell() - 1)

        # Closing module init :
        f.write("\n\n);\n")

        # Starting the differenciation between analog and digital path :
        if analog == False:

            # Adding the wires :
            for wire in internals:
                f.write(
                    f"\n    wire [{str(wire.width).center(8)}] {wire.name.replace("#", "_")};"
                )
            f.write("\n\n")

            def append_module_net(
                netlist: list[dataport], file, module_name, first
            ) -> bool:

                # Iterate over the nets lists :
                for net in netlist:

                    # If the net is from within this module :
                    if net.name.split("#")[0] == module_name:

                        # Append comma if needed
                        if first != False:
                            file.write(",")

                        # Write the verilog syntax to connect it
                        if (net.name.split("#")[-1] in globnet) or (
                            net.name.split("#")[-1] in internet
                        ):
                            file.write(
                                f"\n        .{str(net.name.split("#")[-1]):12}({net.name.split("#")[-1]})"
                            )
                        else:
                            file.write(
                                f"\n        .{str(net.name.split("#")[-1]):12}({net.name.replace("#", "_")})"
                            )
                        first = True

                return first

            # Adding component instantiation now :
            for module in modules:
                f.write(f"    {module} u_{module} (")

                # Append the net names
                first = False
                first = append_module_net(inputs, f, module, first)
                first = append_module_net(outputs, f, module, first)

                f.write("\n    );\n\n")

                # Need to handle the missing pins -> mis_matched naming !

            f.write("endmodule\n\n")

        # Analog mode
        else:

            # Append the disciplines
            for input in inputs:
                f.write(f"    electrical {input.name.split("#")[-1]};\n")
            for output in outputs:
                f.write(f"    electrical {output.name.split("#")[-1]};\n")
            f.write("\n")

            # Append analog corpse (copied from source file)
            f.write("    analog begin\n")

            analog_decl = analog_decl[1:] if analog_decl[0] == "\n" else analog_decl
            f.write(analog_decl)

            f.write("\n\n")

        # Adding end of file mark, and leaving.
        f.write(f"// ===============================================\n")
        f.write(f"// FILE WAS CREATED ON : {datetime.datetime.now()}\n")
        f.write(f"// ===============================================\n")
    return


def generate_analog_spice_string(
    target: Path,
    name: str,
    inputs: list[dataport],
    outputs: list[dataport],
    include: Path,
) -> str:
    """
    This function return the spice string to be added into the XSCHEM symbol for the analog mode.

    Arguments :
        -> target : The name of the subcircuit to be created.
        -> name : The name of the model to be used.
        -> inputs : The list of dataport objects to be used as inputs.
        -> outputs : The list of dataport objects to be used as outputs.
        -> include : The name of the binary file to be included as the library (.osdi)

    Returns :
        -> str : Spice formatted string to include the model.
    """
    # Generate names
    model_name = f"{name}_model"
    subckt_name = str(target.name).split(".")[0]

    # Generating nets names
    inp_name = []
    out_name = []
    for net in inputs:
        inp_name.extend(net.get_ports_name().replace("#", "_").split(" "))
    for net in outputs:
        out_name.extend(net.get_ports_name().replace("#", "_").split(" "))

    inp_str = " ".join(inp_name)
    out_str = " ".join(out_name)

    return f"""
pre_osdi {str(include)}

.subckt {subckt_name} {inp_str} {out_str}
  .Model {model_name} {name}
  .N1 {inp_str} {out_str} {model_name}
.ends
"""


def generate_digital_spice_string(
    target: Path,
    name: str,
    inputs: list[dataport],
    outputs: list[dataport],
    include: Path,
    voltage: float,
) -> str:
    """
    This function generate the spice string to be filled into the XSCHEM symbol, for the digital mode :

    There's the option to choose the voltage standard to any common values.
    In input, the threshold are respectively 0.33 and 0.66 this value, for respectively 0 and 1.
    In output, the values are 0.00 and voltage, for respectively 0 and 1.

    Arguments :
        -> target : The name of the subcircuit.
        -> name : The name of the model.
        -> inputs : List of dataport objects to be used as inputs.
        -> outputs : List of dataport objects to be used as outputs.
        -> include : The binary file to be included as the model (.so)
        -> voltage : The voltage standard to be used.

    Returns :
        -> str : A spice compatible formatted string, which include all the necessary for digital simulations.
    """
    # Generate the names
    model_name = f"{name}_model"
    subckt_name = str(target.name).split(".")[0]

    # First, compute the thresholds
    low_th = round(voltage * 0.33, 1)
    high_th = round(voltage * 0.66, 1)

    # Generating nets names
    inp_name = []
    out_name = []
    for net in inputs:
        inp_name.extend(net.get_ports_name().replace("#", "_").split(" "))
    for net in outputs:
        out_name.extend(net.get_ports_name().replace("#", "_").split(" "))

    inp_str = " ".join(inp_name)
    out_str = " ".join(out_name)

    # Then, generate DACs and ADCs
    adcs = ""
    for index, inp in enumerate(inp_name):
        adcs = adcs + f"\n  ADC{index} {inp} d_{inp} a2d"
    dacs = ""
    for index, out in enumerate(out_name):
        dacs = dacs + f"\n  DAC{index} d_{out} {out} d2a"

    # Generate the digital names ports :
    d_inp_name = " ".join([f"d_{val}" for val in inp_name])
    d_out_name = " ".join([f"d_{val}" for val in out_name])

    return f"""
.subckt {subckt_name} {inp_str} {out_str}
  .model a2d adc_bridge(in_low={low_th} in_high={high_th})
  .model d2a dac_bridge(out_low=0.0 out_high={voltage})

  .model {model_name} d_cosim simulation="{str(include)}"
  {adcs}
  {dacs}

  A{name} [{d_inp_name}] [{d_out_name}] {model_name}
.ends
"""


def generate_sym(
    target: Path,
    analog: bool,
    inputs: list[dataport],
    outputs: list[dataport],
    wires: list[dataport],
    internals: list[dataport],
    include: Path,
    modName: str,
    voltage: float,
) -> None:
    """
    This function generate the XSCHEM symbol, to make connection in mixed sim easier.

    Arguments :
        -> target : The .sym file to be created.
        -> analog : The mode of operation. Set to True if the symbol shall be analog.
        -> inputs : The list of dataport objects to be used as inputs.
        -> outputs : The list of dataport objects to be used as outputs.
        -> wires : The list of dataport objects to be used as shared elements.
        -> internals : The list of dataport objects to be used as private elements.
        -> include : The binary file to be included (.so or .osdi).
        -> modName : The name of the module to be used.
        -> voltage : The voltage standard (only in Digital mode).

    Returns :
        -> None
    """

    # Define space between pins :
    PITCH = 20

    # Define the offsets from the sides :
    OFFSET = PITCH / 2

    # Defie the size of a pad :
    PIN_SIZE = 5

    # Define the offset of a text to it's pad
    TEXT_OFFSET_X = 5
    TEXT_OFFSET_Y = 4
    TEXT_CHAR_SIZE = 2.75

    # Handling the removal of the already_handled nets :
    removals = [net.name for net in internals]
    globnets = [net.name for net in wires]

    removals.extend(globnets)
    removed = []

    def remove_pins(ports: list[dataport]) -> list[dataport]:
        retlist = []
        for port in ports:
            if port.name.split("#")[-1] not in removals:
                retlist.append(port)
            else:
                if port.name.split("#")[-1] not in removed:
                    removed.append(port)
        return retlist

    # Remove global pins (duplicates, to let the symbol simpler : )
    i_inputs = remove_pins(inputs)
    i_outputs = remove_pins(outputs)

    # Finally, append the globnets
    for globnet in wires:
        match globnet.direction:
            case "INPUT":
                i_inputs.insert(0, globnet)
            case "OUTPUT":
                i_outputs.insert(0, globnet)

    with open(target, "w+") as f:

        # Append the basic elements of the file :
        f.write("v {xschem version=3.4.4 file_version=1.2}\n")
        f.write("* This file was autogenerated by the genwrapper script.\n")
        f.write("* Please do not edit it by hand.\n")

        # Append some data :
        f.write("K {}\n")
        f.write("V {}\n")
        f.write("S {}\n")
        f.write("E {}\n\n")

        # Get sizes of the symbol box :
        def get_dimension(size: int) -> int:
            return ((size - 1) * PITCH) + (2 * OFFSET)

        # Then, call the functions and determine the size matrix (with a minimum to 40 to ensure a visible symbol)
        height = max(get_dimension(len(i_inputs)), get_dimension(len(i_outputs)), 80.0)
        width = max(0, 80.0)

        # Define some extrems :
        x_left = -(width / 2)
        x_right = width / 2
        y_top = -(height / 2)
        y_bot = height / 2

        coordinates = [
            [x_left, y_bot, x_left, y_top],
            [x_left, y_top, x_right, y_top],
            [x_right, y_top, x_right, y_bot],
            [x_right, y_bot, x_left, y_bot],
        ]

        # Draw the box on the symbol :
        for coordinate in coordinates:
            f.write(
                f"L 4 {coordinate[0]} {coordinate[1]} {coordinate[2]} {coordinate[3]} {"{}"}\n"
            )
        f.write("\n")

        # Then, create the coordinates for the pins :
        def get_pins_position(
            orig: int, fixed: int, number: int
        ) -> list[list[int, int]]:
            pins = []
            act_pos = orig + OFFSET

            for _ in range(number):
                pins.append([fixed, act_pos])
                act_pos += PITCH

            return pins

        in_pins = get_pins_position(y_top, x_left, len(i_inputs))
        out_pins = get_pins_position(y_top, x_right, len(i_outputs))

        # Then, place the pins on the file :
        def place_pins(
            pins: list[list[int, int]],
            pin_data: list[dataport],
            direction: str,
            pins_cnt,
            file,
        ) -> None:
            for index, pin in enumerate(pins):
                extrems = [
                    [pin[0] - (PIN_SIZE / 2), pin[1] - (PIN_SIZE / 2)],
                    [pin[0] + (PIN_SIZE / 2), pin[1] + (PIN_SIZE / 2)],
                ]

                # Add the pad
                file.write(
                    f"B 5 {extrems[0][0]} {extrems[0][1]} {extrems[1][0]} {extrems[1][1]} {"{"}{f"name={pin_data[index].name.replace("#", "_")} dir={direction} seq={pins_cnt}"}{"}"}\n"
                )

                # Place the text near the pad :
                x_pos = (
                    (pin[0] + TEXT_OFFSET_X)
                    if pin[0] < 0
                    else (
                        pin[0]
                        - TEXT_OFFSET_X
                        - (TEXT_CHAR_SIZE * len(pin_data[index].name))
                    )
                )
                file.write(
                    f"T {"{"}{pin_data[index].name.replace("#", "_")}{"}"} {x_pos} {pin[1] - TEXT_OFFSET_Y} 0 0.1 0.1 {"{}"}\n"
                )
                pins_cnt += 1
            return pins_cnt

        # We add a variable to track the seq id
        pins_cnt = 0
        pins_cnt = place_pins(in_pins, i_inputs, "in", pins_cnt, f)
        pins_cnt = place_pins(out_pins, i_outputs, "out", pins_cnt, f)
        f.write("\n")

        # Add entity name and module :
        name = str(target.name).split(".")[0]
        f.write(
            f"T {"{"}{name}{"}"} {0 - (TEXT_CHAR_SIZE * len(name))} {0 - (TEXT_CHAR_SIZE * len(name))} 0 0 0.2 0.2\n"
        )
        f.write(f"T {"{"}@name{"}"} 0 -10 0 0 0.2 0.2\n")

        # Add the spice string :
        spice_string = ""
        if analog == True:
            spice_string = generate_analog_spice_string(
                target, modName, i_inputs, i_outputs, include
            )
        else:
            spice_string = generate_digital_spice_string(
                target, name, i_inputs, i_outputs, include, voltage
            )

        # Finally, append the spice attributes to the model :
        f.write("\n")
        f.write(f"G {"{"}type=subcircuit \n")
        f.write('format="@name @pinlist @model"\n')
        f.write(f'template="name=X1 model={str(target.name).split(".")[0]}"\n')
        f.write(f'spice_sym_def="{spice_string}"\n')
        f.write("}\n\n")
        f.write("* END OF THE SYMBOL\n")

    return


def print_command_output(data: str) -> None:
    """
    This function print subprocess outputs in a formatted way, to clearly identify the outputs.

    Arguments :
        -> data : the output string of the command

    Returns :
        -> None
    """
    lines = data.split("\n")

    N = 120

    print(">")
    for line in lines:

        # If the line is longer than 120 chars, split it into sublines.
        # Each sublines will be padded a bit more to still get visibility.
        if len(line) > N:
            sublines = textwrap.wrap(line, N)
            print(f">   {sublines[0]}")
            for subline in sublines[1:]:
                print(f">       {subline}")

        # Else, directly print the line, as is.
        else:
            print(f">   {line}")
    print(">")

    return


def generate_osdi(top: Path) -> None:
    """
    This function invoke openvaf-r compiler to build the .osdi file from the .va source.

    Arguments :
        -> top : Source verilogA file.

    Returns :
        -> None
    """
    # Creating the command to be runned :
    tool = f"openvaf-r {top}"
    print(f"Running : {tool}")

    # Prepare args and run the command
    args = shlex.split(tool)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, errors = p.communicate()

    print_command_output(output.decode())
    print_command_output(errors.decode())

    return


def generate_so(top: Path, sources: list[Path]) -> None:
    """
    This function invoke vlnggen script from ngspice to generate (using verilator) the .so file.

    Arguments :
        -> top : The top Verilog file.
        -> sources : The list of Path that contained sources, and thus shall be compiled into the .so file.

    Returns :
        -> None
    """
    # Creating the command to be runned :
    sources_str = " ".join([str(source) for source in sources])
    tool = f"ngspice vlnggen {top} {sources_str}"
    print(f"Running : {tool}")

    # Prepare args and run the command
    args = shlex.split(tool)
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, errors = p.communicate()

    print_command_output(output.decode())
    print_command_output(errors.decode())

    return


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.formatter_class = argparse.RawDescriptionHelpFormatter
    parser.add_argument(
        "files",
        nargs="+",
        help="The input verilog files to be combined into a single top",
    )
    parser.add_argument(
        "-n",
        "--name",
        dest="name",
        default="top.v",
        help="Name of the top module to be used. Default = top.v",
    )
    parser.add_argument(
        "-t",
        "--temp",
        dest="temp",
        default="/tmp/wrappergen",
        help="Path of the temporary json files. Default to /tmp/wrappengen/",
    )
    parser.add_argument(
        "-m",
        "--no-merge-wires",
        dest="merge_wires",
        default=True,
        action="store_false",
        help="Disable the auto merge the wire that share a same net into a single output at the end. Enabled by default.",
    )
    parser.add_argument(
        "-s",
        "--no-sym",
        dest="sym",
        default=True,
        action="store_false",
        help="Do not generate the xschem symbol in the same pass. Symbol is by default generated.",
    )
    parser.add_argument(
        "-a",
        "--analog",
        dest="analog",
        action="store_true",
        help="Enable the analog mode, in which the file is treated as it, and generate a symbol from it. Default to no.",
    )
    parser.add_argument(
        "-v",
        "--voltage",
        dest="voltage",
        default="3.3",
        help='Enable to configure the voltage level used for the ADC / DAC bridges on digital blocks. Ignored for analog blocks. Default to "3.3" (V)',
    )
    parser.add_argument(
        "-o",
        "--output",
        dest="bin_name",
        default="top.so",
        help="Set the name of the OSDI / SO file to be generated (and used in symbol, unless specified to not create a symbol).",
    )
    parser.add_argument(
        "-nb",
        "--no-binary",
        dest="no_binary",
        default=True,
        action="store_false",
        help="Disable binary generation. Otherwise (default), the .osdi or .so file will be generated from the top level file.",
    )
    parser.add_argument(
        "-d",
        "--debug",
        dest="debug",
        default=False,
        action="store_true",
        help="Add some debug logs and prints.",
    )

    parser.description = textwrap.dedent(
        """
        WrapperGen: A Mixed-Signal Integration Tool for Ngspice & Xschem.

        Combines multiple Verilog or a Verilog-A modules into a single top-level wrapper,
        generating the necessary C/C++ binaries (.so/.osdi) and Xschem symbols (.sym).
        Essential for co-simulation (d_cosim) workflows which require a single digital entry point,
        and which can be quite tedious to set up for the first time.
"""
    )

    parser.epilog = textwrap.dedent(
        """ 
        If you have some issues, perhaps use the -m=no / --merge_wires=no option to disable the grouping of the same 
        net ports. With the default value, two ports that share the name "clk" would be exposed as one. This make the 
        design simpler, but could lead to issues. Always start here ! If none of the solution works, you still could 
        write your own top, and let the script only generate the symbol for you !
    
        WARNING : Due to some limitations of the pyverilog library used, some VALID syntax aren't handled (ANSI style). For example, 
        only modules defined as : module(input in, output out); are handled, where 
        the other syntax, module(in, out); input in; output out; won't be handled (will return a 0 port device.).
"""
    )

    # Parse arguments :
    args = parser.parse_args()

    # Print the args
    if args.debug == True:
        print(args)

    # First, ensure path are existing :
    tmp = Path(args.temp)
    tmp.mkdir(parents=True, exist_ok=True)

    # Ensure no more than one file in analog mode was passed :
    if args.analog == "yes":
        if len(args.files) > 1:
            print("In analog mode, no more than one file are handled.")
            exit(1)

    # Generate paths and files lists
    sources = [Path(t).resolve() for t in args.files]
    extracted = [Path(tmp / t.name).with_suffix(".json") for t in sources]
    top = Path(args.name).resolve()
    sym = top.with_suffix(".sym")
    modName = None

    binary = (
        top.with_suffix(".tmp")
        if args.bin_name == "top.so"
        else Path(args.bin_name).resolve()
    )

    # Parsing the remaining args
    voltage = float(args.voltage)

    # init some elements :
    analog_decl = ""

    # If we're in analog mode : Convert the file into it's digital stub
    if args.analog:

        # Generating names for the analog part :
        sources = sources[0]
        binary = binary.with_suffix(".osdi")
        modName = sources.name.split(".")[0]
        vlog = extracted[0].with_suffix(".va")
        top = top.with_suffix(".va")

        print(f"Converting the {sources.name} file into it's verilog stub ...")

        analog_decl = va2v(sources, vlog)
        sources = [vlog]

    else:
        binary = binary.with_suffix(".so")

    # Parse source files
    print(f"Parsing files : {" ".join([source.name for source in sources])}")
    inputs, outputs, modules = parse_file(sources)

    # Optionnaly, match the ports :
    wires = []
    internals = []
    if (args.merge_wires == True) and (args.analog == False):
        print("Combining ports into single ports ...")
        inputs, outputs, wires, internals = match_ports(inputs, outputs)

    # Generating the top entity :
    print(f"Generating verilog {top.name.split(".")[0]} module ...")
    generate_module(
        top, args.analog, modules, inputs, outputs, wires, internals, analog_decl
    )

    # Generating the symbol file:
    if args.sym == True:
        generate_sym(
            sym,
            args.analog,
            inputs,
            outputs,
            wires,
            internals,
            binary,
            modName,
            voltage,
        )

    if args.no_binary:
        print(f"Generating {binary.name} file ...")
        if args.analog:
            generate_osdi(top)
        else:
            generate_so(top, sources)

    # Finish and exit :
    print("Finished generating the required elements !")
