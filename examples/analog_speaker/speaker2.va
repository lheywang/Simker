`include "disciplines.h"
`include "constants.h"

module speaker_distributed_god_mode(p, n, x_mon, sound_out);
    inout p, n;
    output x_mon, sound_out;
    electrical p, n, x_mon, sound_out;

    // ==============================================================================
    // 1. DISTRIBUTED PARAMETERS (The "Breakup" Physics)
    // ==============================================================================
    parameter integer N_SECTIONS = 5; // Higher = More accurate breakup modes
    
    // Total Mass/Damping (Will be distributed)
    parameter real M_cone_total = 20.0m; 
    parameter real R_cone_internal = 5.0; // Internal damping of paper/kevlar

    // Stiffness between sections (How rigid is the paper?)
    parameter real K_cone_stiffness = 50000.0; // Very stiff coupling
    
    
    // ==============================================================================
    // 2. MOTOR PARAMETERS (Geometry & Thermal)
    // ==============================================================================
    parameter real Bl_peak = 12.0;    
    parameter real X_gap   = 8.0m;    // 8mm Gap Height
    parameter real H_coil  = 18.0m;   // 18mm Coil Height (Overhung)
    parameter real Re_0    = 6.0;
    parameter real Le      = 1.5m;
    
    // Thermal
    parameter real R_thermal = 0.8;   // K/W
    parameter real C_thermal = 8.0;   // Thermal Mass
    parameter real Temp_Coeff = 0.00393;

    // ==============================================================================
    // 3. SUSPENSION PARAMETERS (Viscoelasticity / Creep)
    // ==============================================================================
    // SPIDER (Connected to Node 0)
    parameter real K_spider_main = 800.0;
    parameter real K_spider_creep = 400.0; 
    parameter real Tau_spider     = 0.05; // 50ms relaxation

    // SURROUND (Connected to Node N)
    parameter real K_surround_main = 400.0;
    parameter real K_surround_creep = 200.0;
    parameter real Tau_surround     = 0.02; // 20ms relaxation


    // ==============================================================================
    // 4. ACOUSTIC PARAMETERS (Doppler)
    // ==============================================================================
    parameter real C_sound = 343.0;
    parameter real Rho_air = 1.18;
    parameter real Sd      = 0.022; // Surface Area

    // ------------------------------------------------------------------------------
    // INTERNAL NODES & VARS
    // ------------------------------------------------------------------------------
    // The Cone Backbone
    kinematic [0:N_SECTIONS-1] k_node; 
    
    // Relaxation nodes for Creep (Spider and Surround)
    kinematic k_relax_spider;
    kinematic k_relax_surround;
    
    electrical thermal_node; // Voltage = Temperature

    // Calc Variables
    real i_coil, v_coil, x_coil, v_coil;
    real Bl_dynamic, Re_dynamic;
    real power_dississipated;
    real delayed_time;
    real M_sec, R_sec;
    
    // Force placeholders
    real f_spider_visco, f_surround_visco;

    genvar i;

    analog begin
        // --- A. INITIALIZATION & DISTRIBUTION ---
        // Distribute Mass evenly across sections
        M_sec = M_cone_total / N_SECTIONS;
        // Distribute Damping
        R_sec = R_cone_internal / N_SECTIONS;


        // --- B. THERMAL MODEL ---
        i_coil = I(p, n);
        power_dississipated = i_coil * i_coil * Re_0;
        
        // Heat flow into thermal tank
        I(thermal_node) <+ power_dississipated;
        I(thermal_node) <+ ddt(V(thermal_node)) * C_thermal;
        I(thermal_node) <+ V(thermal_node) / R_thermal;
        
        // Modulate Resistance
        Re_dynamic = Re_0 * (1 + Temp_Coeff * V(thermal_node));


        // --- C. GEOMETRIC MOTOR MODEL (Bl calc) ---
        x_coil = Pos(k_node[0]); // Coil is at index 0
        v_coil = ddt(x_coil);

        // Trapezoidal Geometry Calculation
        // Checks overlap of Coil Height vs Gap Height
        if (abs(x_coil) < abs(H_coil - X_gap)/2.0) 
            Bl_dynamic = Bl_peak;
        else if (abs(x_coil) < abs(H_coil + X_gap)/2.0)
            Bl_dynamic = Bl_peak * (1.0 - (abs(x_coil) - abs(H_coil - X_gap)/2.0) / X_gap);
        else
            Bl_dynamic = 0.1; // Leakage field only

        // Electrical KVL
        V(p, n) <+ i_coil * Re_dynamic + ddt(i_coil * Le) + (Bl_dynamic * v_coil);
        
        // Motor Force (Applies only to Node 0)
        F(k_node[0]) <+ -1 * Bl_dynamic * i_coil;


        // --- D. MECHANICAL LOOP (The Distributed Physics) ---
        generate i (0, N_SECTIONS-1) begin
            // 1. Inertia (F=ma) for this segment
            F(k_node[i]) <+ M_sec * ddt(ddt(Pos(k_node[i])));
            F(k_node[i]) <+ R_sec * ddt(Pos(k_node[i]));

            // 2. Coupling (Internal Cone Stiffness)
            // Connects Node[i] to Node[i+1]
            if (i < N_SECTIONS - 1) begin
                // Force pulls 'i' towards 'i+1'
                F(k_node[i]) <+ K_cone_stiffness * (Pos(k_node[i]) - Pos(k_node[i+1]));
                // Equal and opposite force on 'i+1'
                F(k_node[i+1]) <+ -1 * K_cone_stiffness * (Pos(k_node[i]) - Pos(k_node[i+1]));
            end 
        end


        // --- E. VISCOELASTIC BOUNDARY CONDITIONS ---
        
        // 1. SPIDER (At Node 0)
        // Main Spring + Creep Branch
        F(k_node[0]) <+ K_spider_main * Pos(k_node[0]);
        
        // Creep Logic: F = K_relax * (x_main - x_internal)
        f_spider_visco = K_spider_creep * (Pos(k_node[0]) - Pos(k_relax_spider));
        F(k_node[0])        <+ f_spider_visco;
        F(k_relax_spider)   <+ -f_spider_visco + (K_spider_creep * Tau_spider) * ddt(Pos(k_relax_spider));


        // 2. SURROUND (At Node N-1)
        // Main Spring + Creep Branch
        F(k_node[N_SECTIONS-1]) <+ K_surround_main * Pos(k_node[N_SECTIONS-1]);
        
        f_surround_visco = K_surround_creep * (Pos(k_node[N_SECTIONS-1]) - Pos(k_relax_surround));
        F(k_node[N_SECTIONS-1])   <+ f_surround_visco;
        F(k_relax_surround)       <+ -f_surround_visco + (K_surround_creep * Tau_surround) * ddt(Pos(k_relax_surround));


        // --- F. ACOUSTIC OUTPUT (Doppler) ---
        // We use the Coil Velocity for the Doppler Shift source 
        // (Approximation of point source origin)
        
        delayed_time = (1.0 - x_coil) / C_sound;
        
        // Output Pressure = Density * Acceleration * Area / 2piDistance
        // Wrapped in absdelay for the FM effect
        V(sound_out) <+ absdelay( ddt(v_coil) * Rho_air * Sd / 6.28, delayed_time);
        
        // Monitor (Displacement in mm)
        V(x_mon) <+ x_coil * 1000.0;
    end
endmodule