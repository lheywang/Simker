`include "disciplines.h"
`include "constants.h"

// 1. DEFINE KINEMATIC DISCIPLINE (OpenVAF often misses this one)
nature Position
    units = "m";
    access = Pos;
endnature

nature Force
    units = "N";
    access = F;
endnature

discipline kinematic
    potential Position;
    flow Force;
enddiscipline

module speaker_distributed_god_mode(p, n, x_mon, sound_out);
    inout p, n;
    output x_mon, sound_out;
    electrical p, n, x_mon, sound_out;

    // ==============================================================================
    // 1. PARAMETERS
    // ==============================================================================
    parameter integer N_SECTIONS = 5; 
    
    parameter real M_cone_total = 20.0m; 
    parameter real R_cone_internal = 5.0; 
    parameter real K_cone_stiffness = 50000.0; 
    
    parameter real Bl_peak = 12.0;    
    parameter real X_gap   = 8.0m;    
    parameter real H_coil  = 18.0m;   
    parameter real Re_0    = 6.0;
    parameter real Le      = 1.5m;
    
    parameter real R_thermal = 0.8;   
    parameter real C_thermal = 8.0;   
    parameter real Temp_Coeff = 0.00393;

    parameter real K_spider_main = 800.0;
    parameter real K_spider_creep = 400.0; 
    parameter real Tau_spider     = 0.05; 

    parameter real K_surround_main = 400.0;
    parameter real K_surround_creep = 200.0;
    parameter real Tau_surround     = 0.02; 

    parameter real C_sound = 343.0;
    parameter real Rho_air = 1.18;
    parameter real Sd      = 0.022; 

    // ==============================================================================
    // 2. NODES & VARIABLES
    // ==============================================================================
    // Array Declaration
    // Note: If OpenVAF fails here on specific versions, hardcode to [0:4]
    kinematic [0:4] k_node; 
    
    kinematic k_relax_spider;
    kinematic k_relax_surround;
    
    electrical thermal_node; 

    real i_coil, x_coil, v_coil; // Removed duplicate v_coil
    real Bl_dynamic, Re_dynamic;
    real power_dississipated;
    real delayed_time;
    real M_sec, R_sec;
    
    real f_spider_visco, f_surround_visco;

    // 3. USE INTEGER FOR ANALOG LOOPS (Not genvar)
    integer i;

    analog begin
        // --- A. INITIALIZATION ---
        M_sec = M_cone_total / N_SECTIONS;
        R_sec = R_cone_internal / N_SECTIONS;


        // --- B. THERMAL MODEL ---
        i_coil = I(p, n);
        power_dississipated = i_coil * i_coil * Re_0;
        
        I(thermal_node) <+ power_dississipated;
        I(thermal_node) <+ ddt(V(thermal_node)) * C_thermal;
        I(thermal_node) <+ V(thermal_node) / R_thermal;
        
        Re_dynamic = Re_0 * (1 + Temp_Coeff * V(thermal_node));


        // --- C. MOTOR MODEL ---
        x_coil = Pos(k_node[0]); 
        v_coil = ddt(x_coil);

        if (abs(x_coil) < abs(H_coil - X_gap)/2.0) 
            Bl_dynamic = Bl_peak;
        else if (abs(x_coil) < abs(H_coil + X_gap)/2.0)
            Bl_dynamic = Bl_peak * (1.0 - (abs(x_coil) - abs(H_coil - X_gap)/2.0) / X_gap);
        else
            Bl_dynamic = 0.1; 

        V(p, n) <+ i_coil * Re_dynamic + ddt(i_coil * Le) + (Bl_dynamic * v_coil);
        F(k_node[0]) <+ -1 * Bl_dynamic * i_coil;


        // --- D. MECHANICAL LOOP (FIXED) ---
        // Use a standard FOR loop inside analog block
        for (i = 0; i < N_SECTIONS; i = i + 1) begin
            
            // 1. Inertia & Damping
            F(k_node[i]) <+ M_sec * ddt(ddt(Pos(k_node[i])));
            F(k_node[i]) <+ R_sec * ddt(Pos(k_node[i]));

            // 2. Coupling to NEXT node
            if (i < N_SECTIONS - 1) begin
                F(k_node[i]) <+ K_cone_stiffness * (Pos(k_node[i]) - Pos(k_node[i+1]));
                F(k_node[i+1]) <+ -1 * K_cone_stiffness * (Pos(k_node[i]) - Pos(k_node[i+1]));
            end 
        end


        // --- E. VISCOELASTIC BOUNDARY ---
        
        // Spider (Node 0)
        F(k_node[0]) <+ K_spider_main * Pos(k_node[0]);
        f_spider_visco = K_spider_creep * (Pos(k_node[0]) - Pos(k_relax_spider));
        F(k_node[0])        <+ f_spider_visco;
        F(k_relax_spider)   <+ -f_spider_visco + (K_spider_creep * Tau_spider) * ddt(Pos(k_relax_spider));

        // Surround (Node 4) - HARDCODED INDEX if N=5
        // Ideally use N_SECTIONS-1, but for safety with arrays use 4
        F(k_node[4]) <+ K_surround_main * Pos(k_node[4]);
        f_surround_visco = K_surround_creep * (Pos(k_node[4]) - Pos(k_relax_surround));
        F(k_node[4])   <+ f_surround_visco;
        F(k_relax_surround)       <+ -f_surround_visco + (K_surround_creep * Tau_surround) * ddt(Pos(k_relax_surround));


        // --- F. OUTPUT ---
        delayed_time = (1.0 - x_coil) / C_sound;
        V(sound_out) <+ absdelay( ddt(v_coil) * Rho_air * Sd / 6.28, delayed_time);
        V(x_mon) <+ x_coil * 1000.0;
    end
endmodule
